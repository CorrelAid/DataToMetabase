---
title: "Metabase Requests"
output: html_document
date: "2022-11-09"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Credentials

In order to make sure that not sensitive information are included in code files
we load then from the environment, where they where added by the `.Renviron`
file. In order to run this document you therefore need to define the
environment variables `METABASE_USER`, `METABASE_PWD` and `METABASE_API_URL`.

```{r credentials}
creds <- list(
  username = Sys.getenv("METABASE_USER"),
  password = Sys.getenv("METABASE_PWD")
)
api_url <- Sys.getenv("METABASE_API_URL")
```

Our api url `r api_url` is not actually sensitive, but since a base_url can
potentially change, its configuration is included in the
environment. Not that the `/api` is part of the url already, so no additional
`/api` path is needed when using metabase api endpoints.

## Basic requests

In this document we'll use `httr` to make http requests. We won't import
`httr` in order to make the usage of its functions explicit. For further
information please refer to the
[httr documentation](https://httr.r-lib.org/index.html)

In order to do
anything interesting we'll first need to get a session token for metabase.
The following snippet fetches a session token.

```{r session_token}
response <- httr::POST(paste0(api_url, "/session"),
  body = creds,
  encode = "json"
)

httr::message_for_status(response)
session <- httr::content(response, as = "parsed")
```

Not the usage of `message_for_status` which we use purely to illustrate the
http status. In further applications the similar function `stop_for_status`
is often useful as it will stop the program if there is an http issue.

The variable session is now a list containing the field `id` with our session
token. Session tokens, although only valid up to two weeks are also sensitive
and should not be printed in documents that will be committed.

### Getting information

We can now use the session token to get data from and to metabase in a similar
fashion to the above POST request. As a simple request we could fetch a
collection to explore.

```{r collections, results='hide'}
httr::add_headers("X-Metabase-Session" = session$id)
response <- httr::GET(paste0(api_url, "/collection/12"))
httr::stop_for_status(response)
collection <- httr::content(response, as = "parsed")
message(collection$name)
```

While this works well, we'll fetch data from a few other API endpoints in this
document so it makes sense to wrap the functionality in a function.

```{r get_function}
get_from_metabase <- function(endpoint) {
  httr::add_headers("X-Metabase-Session" = session$id)
  response <- httr::GET(paste0(api_url, endpoint))
  httr::stop_for_status(response)
  httr::content(response, as = "parsed")
}
```

We can now for instance look at all the cards in this collection. But in order
to continue we'll just fetch the ids of the elements.

```{r example_card_id}
items <- get_from_metabase("/collection/12/items")
sapply(items$data, function(elem) {
  elem$id
})
```

## Closer look at cards

The goal of the project is to create cards automatically via the API. As
expected for a RESTful API and confirmed by the [documentation](https://www.metabase.com/docs/latest/api/card#post-apicard),
this is done by a POST request to the card endpoint. The only issue with this is
that this endpoint takes up to 11 different parameters, in particular a query
parameter. In order to create cards successfully we therefore have to understand
what to pass to these parameters and in order to do that we can look at cards
that have been created manually.

In the previous section we determined card ids and can now put some of our
functionality into action.

```{r card_query1, error=TRUE}
get_from_metabase(paste0("/card/", 16))$dataset_query
```

```{r card_query2, error=TRUE}
query <- get_from_metabase(paste0("/card/", 17))$dataset_query
query
```

```{r card_query3, error=TRUE}
query <- get_from_metabase(paste0("/card/", 98))$dataset_query
query$type
query$query$`source-table`
query$database
```

We only show a small part of the query for case 3 because the details are too
long to dicsuss here. Nevertheless we notic three important things.

1. We don't seem to
have access to card 16. But we actually get a proper error for this, due to
the `stop_for_status_method`.
2. There seems to be different types of queries. Here we saw "native" and
"query".
3. References to databases and tables are just numbers. That we'll need to map.

## Reference data

As the last part of this exploratory document we'll have a look at where to
find reference data for queries. Let us first look at the existing databases.
Note the trailing `/` in the endpoint in agreement with the [docs](https://www.metabase.com/docs/latest/api/database#get-apidatabase).
Forgetting such trailing slashes by accident is a common gotcha for REST APIs.

```{r reference_data}
output <- get_from_metabase("/database/")
lapply(output$data, function(database) {
  list(name = database$name, id = database$id)
})
```

Here we can identify two databases and proceed with the ID for the coolify
database. At this point we will also be using some tidyverse functionality to
more conveniently handle the tabular data.

```{r,include=FALSE}
library(tidyverse)
```

```{r schema}
get_from_metabase("/database/7/schemas")

tables <- get_from_metabase("/database/7/schema/public")
do.call(bind_rows, tables) %>% select(name, display_name, id)
```

```{r fields}
fields <- get_from_metabase("/database/7/fields")
do.call(bind_rows, fields) %>% filter(table_name == "Penguins")
```
