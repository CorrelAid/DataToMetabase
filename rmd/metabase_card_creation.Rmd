---
title: "Metabase Card Creation"
output: html_document
date: "2022-11-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The intention of this document is to illustrate how to create cards on metabase
via the RESTful API. The main focus is on the required payload. 

```{r credentials}
creds <- list(
  username = Sys.getenv("METABASE_USER"),
  password = Sys.getenv("METABASE_PWD")
)
api_url <- Sys.getenv("METABASE_API_URL")
response <- httr::POST(paste0(api_url, "/session"),
  body = creds,
  encode = "json"
)

httr::message_for_status(response)
session <- httr::content(response, as = "parsed")
```

For work with the RESTful API we define functions to GET, POST and DELETE
from the API. the GET and DELETE definitions follow. The definition of the
function for POST is shown further below, as we will discuss a few suttle
issues of it wrt. card creation.

```{r get_function}
get_from_metabase <- function(endpoint, query = NULL) {
  response <- httr::GET(
    paste0(api_url, endpoint),
    query = query,
    httr::add_headers("X-Metabase-Session" = session$id)
  )
  httr::stop_for_status(response)
  httr::content(response, as = "parsed")
}
```
```{r delete_function}
delete_from_metabase <- function(endpoint) {
  response <- httr::DELETE(
    paste0(api_url, endpoint),
    httr::add_headers("X-Metabase-Session" = session$id)
  )
  httr::stop_for_status(response)
  httr::content(response, as = "parsed")
}
```

In order to more conveniently fetch and discuss some metabase data, we also
define a few wrappers to fetch certain metabase endpoints and parse the results.
For brevity we hide the implementation. Please refer to the rmd source code
for details. The functions are `get_databases`, `get_tabels`, `get_collections`
and `get_cards`.
```{r get_helpers, include=FALSE}
get_databases <- function() {
  databases <- get_from_metabase("/database")
  do.call(
    dplyr::bind_rows,
    lapply(databases$data, function(data) {
      list(id = data$id, name = data$name)
    })
  )
}

get_tables <- function(database_id) {
  db <- get_from_metabase(
    paste0("/database/", database_id),
    query = list(include = "tables")
  )
  do.call(dplyr::bind_rows, db$tables)
}

get_collections <- function(archived = "false") {
  collections <- get_from_metabase(
    "/collection/",
    query = list(archived = archived)
  )
  do.call(
    dplyr::bind_rows,
    lapply(collections, function(col) {
      list(id = col$id, name = col$name, archived = col$archived)
    })
  )
}

get_cards <- function(collection_id) {
  items <- get_from_metabase(
    paste0("/collection/", collection_id, "/items")
  )
  do.call(
    dplyr::bind_rows,
    lapply(items$data, function(d) {
      list(id = d$id, model = d$model, name = d$name)
    })
  )
}
```

## Card creation

To create cards we'll use the following function to send POST requests to
metabase. This function explicitly converts the provided payload into
a json that is then passed to the request via the `encode='raw'` option.
Usually one can also pass nested R lists, directly to `httr::POST` using the
`encode='json'` option. This is almost equivalent to what we've done, but there
are edge cases where the two options vary and these edge cases are important
for the metamask API.

```{r post_function}
post_on_metabase <- function(endpoint, payload = list()) {
  response <- httr::POST(
    paste0(api_url, endpoint),
    body = jsonlite::toJSON(payload, auto_unbox = TRUE),
    encode = "raw",
    httr::content_type_json(),
    httr::add_headers("X-Metabase-Session" = session$id)
  )
  httr::stop_for_status(response)
  httr::content(response, as = "parsed")
}
```

We will now define a working payload. Which requres several peices of mandatory information. Namely

- collection_id
- database (also an id)
- source-table (also an id) 
- a card name

### Collection ID
We get the collection id from the API
```{r collection_id}
get_collections()
```
### Database ID and source tbale

The same goes for the database id and the source table.

```{r database_info}
get_databases()
get_tables(7) %>%
  select(id, name) %>%
  filter(name == "penguins")
```

### Payload
With these information a simple payload can be build

```{r card_example}
card_payload <- list(
  visualization_settings = setNames(list(), character(0)),
  collection_id = 11,
  name = "Test Card",
  dataset_query = list(
    database = 7,
    query = list(
      `source-table` = 239
    ),
    type = "query"
  ),
  display = "table"
)
```

In order to check the card creation we will now create a card, execute the
resulting query and then delete the card again (such that this file does
not create too many cards)

```{r create_card}
card_creation_response <- post_on_metabase("/card", card_payload)
post_on_metabase(paste0("/card/", card_creation_response$id, "/query/csv"))
delete_from_metabase(paste0("/card/", card_creation_response$id))
```

#### Subtle Issues

Even though the card creation already workd lets discuss a few subtle issues
invovled in creating the payload. They are best illustrated by the
`visualization_settings` of the above payload.

We don't requre `visualization_settings` for creating basic cards. However
`visualization_settings` are a mandatory part of the payload. For empty
`visualization_settings` the API expects an empty mapping on the json level,
i.e. `"visualization_settings": {}`. In R mappings are generally represented
by named lists, whereas lists without names get mapped to arrays in JSON.

Named lists are usually created by simply specifying the names of the elements,
for instance `list(a=1)`. The challenge that arises now is to create a named
list without any elements. This is done with the expression `setNames(list(),character(0))`.

Another subtle issue is, that such empty lists are filtered our by `httr` when
using the `encode='json'` option. This is the reason we wrote a post function
to use `encode='raw'`.

## More card examples

For more card examples we define the following function.

```{r card_function}
create_card <- function(name, collection_id, query) {
  payload <- list(
    visualization_settings = setNames(list(), character(0)),
    collection_id = collection_id,
    name = name,
    dataset_query = query,
    display = "table"
  )
  card_response <- post_on_metabase("/card", payload)
  card_response$id
}
```

```{r queries}
abstract_query <- list(
  database = 7,
  type = "query",
  query = list(
    `source-table` = 239
  )
)

native_query <- list(
  database = 7,
  type = "native",
  native = list(
    query = "select * from penguins",
    `template-tags` = setNames(list(), character(0))
  )
)
```

```{r abstract_qery}
card_id <- create_card("Card 1", 11, abstract_query)
post_on_metabase(paste0("/card/", card_id, "/query/csv"))
delete_from_metabase(paste0("/card/", card_id))
```

```{r native_qery}
card_id <- create_card("Card 2", 11, native_query)
post_on_metabase(paste0("/card/", card_id, "/query/csv"))
delete_from_metabase(paste0("/card/", card_id))
```
